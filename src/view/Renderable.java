package view;


import _images.ImageCache;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;


/**
 * RenderableImage
 *
 * Represents a render-ready view object whose visual state persists across
 * frames. Each instance corresponds to a single VObject and holds:
 *
 * • The last RenderInfoDTO snapshot (position, size, angle, color, etc.) • A
 * cached BufferedImage sprite generated by SpriteCache • The last frame in
 * which it was updated (for lifecycle management)
 *
 * The sprite is only regenerated when visual parameters that affect its
 * appearance change (imageId, size, angle, color). On every frame, however, the
 * positional data in the RenderInfoDTO is updated so that drawing remains
 * accurate without recreating the underlying image.
 *
 * The goal is to minimize per-frame CPU work and allow the Renderer to blit
 * precomputed GPU-compatible images for thousands of objects efficiently.
 */
public class Renderable {

    private final int entityId;
    private int lastFrameSeen;
    private final ImageCache cache;
    private RenderInfoDTO renderInfo = null;
    private BufferedImage image = null;


    public Renderable(RenderInfoDTO renderInfo, ImageCache cache, int currentFrame) {
        this.entityId = renderInfo.entityId;
        this.lastFrameSeen = currentFrame;
        this.renderInfo = renderInfo;
        this.cache = cache;
        this.updateImage(renderInfo);
    }


    /**
     * PUBLICS
     */
    public int getLastFrameSeen() {
        return this.lastFrameSeen;
    }


    public void update(RenderInfoDTO newRenderInfo, int currentFrame) {
        this.updateImage(newRenderInfo);
        this.lastFrameSeen = currentFrame;
        this.renderInfo = newRenderInfo;
    }


    public void paint(Graphics2D g) {
        int x = (int) (this.renderInfo.posX - this.renderInfo.size);
        int y = (int) (this.renderInfo.posY - this.renderInfo.size);

        if (this.image != null) {
            g.drawImage(this.image, x, y, null);
        }
    }


    /**
     * PRIVATE
     */
    private void updateImage(RenderInfoDTO newRenderInfo) {
        boolean imageNeedsUpdate
                = this.image == null
                || this.renderInfo == null
                || !this.renderInfo.assetId.equals(newRenderInfo.assetId)  
                || this.renderInfo.size != newRenderInfo.size
                || this.renderInfo.angle != newRenderInfo.angle
                || (this.renderInfo.color == null 
                || !this.renderInfo.color.equals(newRenderInfo.color));

        if (imageNeedsUpdate) {
            this.image = this.cache.getImage(newRenderInfo.angle, newRenderInfo.color, newRenderInfo.assetId, newRenderInfo.size);
        }
    }
}
