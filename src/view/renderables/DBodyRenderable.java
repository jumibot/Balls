package view.renderables;


import _images.ImageCache;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;


/**
 * Renderable
 *
 * Represents a render-ready entity object whose visual state persists across
 * frames. Each instance corresponds to a single entity and holds:
 *
 * • The last RenderInfoDTO snapshot (position, size, angle, color, etc.) • A
 * cached BufferedImage sprite generated by SpriteCache • The last frame in
 * which it was updated (for lifecycle management)
 *
 * The sprite is only regenerated when visual parameters that affect its
 * appearance change (imageId, size, angle, color). On every frame, however, the
 * positional data in the RenderInfoDTO is updated so that drawing remains
 * accurate without recreating the underlying image.
 *
 * The goal is to minimize per-frame CPU work and allow the Renderer to blit
 * precomputed GPU-compatible images for thousands of objects efficiently.
 */
public class DBodyRenderable {

    private final int entityId;
    private int lastFrameSeen;
    private final ImageCache cache;
    private DBodyInfoDTO bodyInfo = null;
    private BufferedImage image = null;


    public DBodyRenderable(DBodyInfoDTO bodyInfo, ImageCache cache, int currentFrame) {
        this.entityId = bodyInfo.entityId;
        this.lastFrameSeen = currentFrame;
        this.bodyInfo = bodyInfo;
        this.cache = cache;
        this.updateImageFromCache(bodyInfo);
    }


    /**
     * PUBLICS
     */
    public int getLastFrameSeen() {
        return this.lastFrameSeen;
    }


    public void update(DBodyInfoDTO newBodyInfo, int currentFrame) {
        this.updateImageFromCache(newBodyInfo);
        this.lastFrameSeen = currentFrame;
        this.bodyInfo = newBodyInfo;
    }


    public void paint(Graphics2D g) {
        int x = (int) (this.bodyInfo.posX - this.bodyInfo.size);
        int y = (int) (this.bodyInfo.posY - this.bodyInfo.size);

        if (this.image != null) {
            g.drawImage(this.image, x, y, null);
        }
    }


    /**
     * PRIVATE
     */
    private void updateImageFromCache(DBodyInfoDTO bodyInfo) {
        boolean imageNeedsUpdate
                = this.image == null
                || this.bodyInfo == null
                || !this.bodyInfo.assetId.equals(bodyInfo.assetId)
                || this.bodyInfo.size != bodyInfo.size
                || this.bodyInfo.angle != bodyInfo.angle;

        if (imageNeedsUpdate) {
            this.image = this.cache.getImage(bodyInfo.angle, bodyInfo.assetId, (int) bodyInfo.size);
        }
    }
}
