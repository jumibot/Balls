package view;


import _images.SpriteCache;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;


/**
 * RenderableSprite
 *
 * Represents a render-ready view object whose visual state persists across
 * frames. Each instance corresponds to a single VObject and holds:
 *
 * • The last RenderInfoDTO snapshot (position, size, angle, color, etc.) • A
 * cached BufferedImage sprite generated by SpriteCache • The last frame in
 * which it was updated (for lifecycle management)
 *
 * The sprite is only regenerated when visual parameters that affect its
 * appearance change (imageId, size, angle, color). On every frame, however, the
 * positional data in the RenderInfoDTO is updated so that drawing remains
 * accurate without recreating the underlying image.
 *
 * The goal is to minimize per-frame CPU work and allow the Renderer to blit
 * precomputed GPU-compatible images for thousands of objects efficiently.
 */
public class RenderableSprite {

    private final int idVObject;
    private int lastFrameSeen;
    private RenderInfoDTO renderInfo;
    private BufferedImage sprite;


    public RenderableSprite(RenderInfoDTO rInfo, SpriteCache cache, int currentFrame) {
        this.idVObject = rInfo.idVObject;
        this.lastFrameSeen = currentFrame;
        this.renderInfo = rInfo;
        this.updateSprite(rInfo, cache);
    }


    /**
     * PUBLICS
     */
    public int getLastFrameSeen() {
        return this.lastFrameSeen;
    }


    public void update(RenderInfoDTO newRInfo, SpriteCache cache, int currentFrame) {
        this.updateSprite(newRInfo, cache);
        this.lastFrameSeen = currentFrame;
        this.renderInfo = newRInfo;
    }


    public void paint(Graphics2D g) {
        int x = (int) (this.renderInfo.posX - this.renderInfo.size);
        int y = (int) (this.renderInfo.posY - this.renderInfo.size);

        if (this.sprite != null) {
            g.drawImage(this.sprite, x, y, null);
        }
    }


    /**
     * PRIVATE
     */
    private void updateSprite(RenderInfoDTO newRInfo, SpriteCache cache) {
        boolean spriteNeedsUpdate
                = this.sprite == null
                || this.renderInfo == null
                || this.renderInfo.idImage != newRInfo.idImage
                || this.renderInfo.size != newRInfo.size
                || this.renderInfo.angle != newRInfo.angle
                || (this.renderInfo.color != null && !this.renderInfo.color.equals(newRInfo.color));

        if (spriteNeedsUpdate) {
            this.sprite = cache.getSprite(
                    newRInfo.angle, newRInfo.color, newRInfo.idImage, newRInfo.size);
        }
    }
}
